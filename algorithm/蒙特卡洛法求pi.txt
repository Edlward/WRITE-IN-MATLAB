用Python的实现：
# pi.py
from random import random
from math import sqrt
from time import clock
DARTS = 1200
hits = 0
clock()
for i in range(1, DARTS):
    x, y = random(), random();
    dist = sqrt(x**2 + y**2)
    if dist <= 1.0:
        hits = hits + 1
pi = 4 * (hits/DARTS)
print('Pi的值是 %s' % pi)
print('程序的运行时间是 %-5.5ss' % clock())
--------------------- 
作者：JimmieZou 
来源：CSDN 
原文：https://blog.csdn.net/daniel960601/article/details/79121055 
版权声明：本文为博主原创文章，转载请附上博文链接！
代码中用到了random和math库的random()函数和sqrt()函数，为了统计时间，还用到了time库的clock()函数。投入的点越多，计算值越精确。

C++实现：
给定边长为R的正方形，画其内切圆，然后在正方形内随机打点，设点落在圆内的概为P，则根据概率学原理：
P = 圆面积 / 正方形面积 ＝ PI * R * R / 2R * 2R = PI / 4。
即 PI=4P。这样，当随机打点足够多时，统计出来的概率就非常接近于PI的四分之一
#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

int main()
{
	const int MAX_TIMES = 200000000;
	s(static_cast<unsigned int>(time(0)));

	int inside = 0;
	for(int i = 0; i < MAX_TIMES; ++i) {
		double x = static_cast<double>(rand()) / RAND_MAX;
		double y = static_cast<double>(rand()) / RAND_MAX;
		if(x * x + y * y <= 1.0) ++inside;
		if(i % (MAX_TIMES / 100) == 0) cout << '.';
	}	
	
	double pi = 4.0 * inside / MAX_TIMES;
	cout << "/nPI = " << pi << endl;
	return 0;
}




matlab代码： 
monte_carlo_method.m

%% Monte Carlo方法计算π
%正方形内部有一个相切的圆，它们的面积之比是π/4
clc,clear
r=1;
center_x=1;
center_y=1;
num=100000;%随机样本数
fprintf('开始Monte Carlo方法计算圆周率π,随机样本数为%d...\n',num);
s=rng;
rng(s);
sample_point=2*rand(2,num);
total_in=0;
for i=1:num
    distance=sqrt((sample_point(1,i)-1)^2+(sample_point(2,i)-1)^2);
    if distance<1
        total_in=total_in+1;
    end
end
my_pi=total_in/num*4;
fprintf('result:\nπ=%.4f\n',my_pi);
error=abs((pi-my_pi)/pi);
fprintf('误差：%.4f\n',error);
fprintf('完成!\n');

%% 绘图
fprintf('开始绘图...');
figure
scatter(sample_point(1,:),sample_point(2,:),'bo');hold on
circle(1,[1,1]);
title('Monte Carlo方法计算圆周率π'),xlabel('x'),ylabel('y')
axis([0,2,0,2])
fprintf('完成!\n');
---------------------

%circle.m

function circle(R,Center)
alpha=0:pi/50:2*pi;%角度[0,2*pi]
% R=2;%半径
% Center=[1,1];%圆心
x=R*cos(alpha)+Center(1);
y=R*sin(alpha)+Center(2);
plot(x,y,'g-','LineWidth',2)
end
--------------------- 
作者：辰冬 
来源：CSDN 
原文：https://blog.csdn.net/u010585964/article/details/79402147 
版权声明：本文为博主原创文章，转载请附上博文链接！
